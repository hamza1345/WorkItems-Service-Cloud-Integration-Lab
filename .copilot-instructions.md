# Instructions Copilot - Développement Salesforce Apex

## Projet
- Version API : 65.0
- Repository : github.com/hamza1345/WorkItems-Service-Cloud-Integration-Lab
- Branche : develop

---

## 19 Standards à Respecter

### Partage & Sécurité
1. Déclarer le sharing : `public with sharing` (données) ou `public without sharing` (utilitaires)
2. Valider CRUD : `sObjectType.getDescribe(SObjectDescribeOptions.DEFERRED).isAccessible()`
3. Utiliser DEFERRED pour lazy-loading des describes

### Boucles & Performance
4. Pas de SOQL dans les boucles → Bulkifier avec l'opérateur `IN` (limite 100)
5. Pas de DML dans les boucles → DML après la boucle (limite 150)
6. Pas d'IDs en dur → Utiliser CustomMetadata

### Qualité du Code
7. Centraliser SOQL/DML dans les méthodes `@TestVisible`
8. Pas de `System.debug()` en production
9. Constantes pour les nombres magiques : `private static final`
10. Noms clairs : `customerName` pas `a` ou `x`

### Sécurité
11. Fallbacks sûrs pour données null
12. Try-catch autour de SOQL/DML
13. `@TestVisible` sur les méthodes test-only
14. Cacher les opérations coûteuses
15. Ajouter `@description` sur chaque méthode

### Documentation
16. Supprimer le code inutilisé
17. Pas d'espaces en fin de ligne
18. Couverture minimale 80%+ de tests
19. `@SuppressWarnings` uniquement si justifié

---

## Checklist Rapide

- [ ] Modèle de sharing déclaré
- [ ] CRUD validé
- [ ] Pas de boucles avec SOQL/DML
- [ ] Pas d'IDs en dur
- [ ] Try-catch sur les opérations BD
- [ ] Pas de System.debug()
- [ ] Constantes au lieu de nombres magiques
- [ ] Noms de variables clairs
- [ ] @TestVisible sur les méthodes internes
- [ ] @description sur les méthodes
- [ ] Gestion sûre des null
- [ ] Pas d'espaces en fin de ligne
- [ ] Couverture 80%+
- [ ] Scanner ok : `sf scanner:run`

---

## Limites de Gouvernance

| Limite | Max | Solution |
|--------|-----|----------|
| Requêtes SOQL | 100 | Bulkifier avec `IN` |
| Déclarations DML | 150 | DML après boucle |
| Temps CPU | 10s | Optimiser boucles |
| Heap size | 6 MB | Cacher résultats |

---

## Patterns de Code

### Validation CRUD
```apex
SObjectType sObjectType = Account.sObjectType;
if (!sObjectType.getDescribe(SObjectDescribeOptions.DEFERRED).isAccessible()) {
    return new List<Account>();
}
List<Account> accounts = [SELECT Id, Name FROM Account];
```

### Bulkifier SOQL
```apex
Set<Id> accountIds = new Set<Id>();
for (Account acc : accounts) {
    accountIds.add(acc.Id);
}
List<Contact> contacts = [SELECT Id, AccountId FROM Contact WHERE AccountId IN :accountIds];
```

### Bulkifier DML
```apex
for (Opportunity opp : opportunities) {
    opp.StageName = 'Closed Won';
}
update opportunities;
```

### Fallbacks Sûrs
```apex
try {
    result = queryData();
} catch (Exception e) {
    result = getDefaultData();
}
```

### Pattern de Caching
```apex
@TestVisible
private static MyConfig__mdt cached;
@TestVisible
private static Boolean initialized = false;

private static void init() {
    if (initialized) return;
    cached = [SELECT ... LIMIT 1];
    initialized = true;
}
```

### Template de Classe
```apex
/**
 * @description Objectif de la classe.
 */
public with sharing class MyClass {
    private static final String DEFAULT = 'valeur';
    
    /**
     * @description Objectif de la méthode.
     * @return Type du résultat
     */
    public static String myMethod() {
        try {
            return '';
        } catch (Exception e) {
            return null;
        }
    }
}
```

### Template de Test
```apex
@IsTest
private class MyClassTest {
    
    @IsTest
    static void testCasHeureux() {
        // Arrange
        
        // Act
        
        // Assert
        Assert.isTrue(true);
    }
}
```

 # Normes de développement et bonnes pratiques
## Apex Doc
- Une classe ou une méthode disposera toujours d'une documentation Apex avec le format suivant :
    ```
    /**
    * @author ici le nom du développeur
    * @date ici la date du jour au format JJ/MM/AAAA
    * @description une description de la méthode, laisse vide si la méthode ou classe n'est pas encore écrite
     */
    ```
- Pour les méthodes on pourra ajouter en dessous de "@description":
    - une ligne par paramètre avec ce format ```* @param nom du paramètre type du paramètre : utilité```, par exemple : ```* @param pId String : l'identifiant de l'enregistrement```	
    - si le type de retour de la méthode n'est pas "void", une ligne avec ce format ```* @return type de retour de la méthode : descriptif du retour```
- Les méthodes retournant 'void' n'ont pas besoin de ligne "@return"
- Les méthodes sans paramètres n'ont pas besoin de ligne "@param"
- L'Apex Doc se positionne avant la déclaration de la classe ou de la méthode
- Les classes et méthodes de test ont également une Apex Doc
- Pour le nom de l'auteur, mettre le nom complet du développeur et non pas ton nom "Github Copilot"

## Bonnes pratiques Apex générales
- Ne pas laisser de "System.debug" dans le code
- Supprimer les variables inutilisées
- Ne pas utiliser de "booléen == true" dans les conditions, utiliser plutôt "if (booléen)" ou "if (!booléen)"
- Utiliser "List.isEmpty()" au lieu de "List.size() > 0"
- Les classes doivent être déclarées "public with sharing"
- Ne pas utiliser de classe "Global"
- La version d'API des classes Apex doit être supérieure ou égale à l'API en cours - 3
- les chaînes de caractères comme des messages d'information, erreur ou autres doivent être mis sous forme de Custom Label
- Les chaines de caractèrs utilisées à plusieurs endroits doivent êtr mises en constantes statiques
- les constantes statiques sont déclarées en début de classe, avant le constructeur
- les constantes statiques sont déclarées avec le mot clé "static" et "final"
- les constantes statiques sont en majuscules avec un "_" entre chaque mot
- Les constantes relatives à un objet doivent être externalisées dans l'entity manager associé
- Respecter la syntaxe camelCase pour les variables et méthodes
- Respecter la syntaxe PascalCase pour les classes
- Favoriser l'utilisation de "switch" plutôt que de "if" pour les conditions multiples
- Pour le nom de l'auteur, mettre le nom complet du développeur et non pas ton nom "Github Copilot"
### Bonnes pratiques pour les classes de test
- Utilise toujours la librairie "Assert" pour les assertions
- Ajoute un message aux assertions pour donner des précisions lorsque l'assertion échoue
- Utilise la méthode "TestDataFactory" pour créer des données de test
- Les classes de test et méthodes de test sont annotées avec "@isTest"
- Les classes de test sont nommées avec le suffix "_TEST"
- Les méthodes de tests sont nommées de la mnière suivante : "nomDeLaMéthode" + "CasTeste" + "Test"
- Les classes de tests doivent couvrir tous les cas passant et non passants des méthodes testées
- Utiliser la méthode "Test.startTest()" et "Test.stopTest()" pour délimiter les tests
- Utiliser la méthode "Test.setMock()" pour simuler des appels externes
- Dans la méthode "TestSetup", créer les données de test communes à tous les tests
- Dans la méthode "TestSetup", ne créer que les données nécessaires aux tests, pas de données inutiles
- Pour les couches de façade et de Service Manager, utiliser la méthode "System.runAs()" pour tester les permissions des utilisateurs
- Ne pas annoter les classes ou méthode avec "SeeAllData=true"
- Ne pas utiliser de 'Assert.isNull()' sur des listes, utiliser plutôt 'Assert.isTrue()' ou 'Assert.isFalse()' avec 'isEmpty()
- Lors de la création d'un utilisateur, utiliser un nom d'utilisateur unique pour éviter les conflits => spécifier le nom de la classe dans le nom d'utilisateur

## Lightning Web Component (LWC)
- variables déclarées avec "const" et "let" uniquements
- utiliser '===' ou '!==' pour faire des comparaisons sauf pour tester si la variables est "undefined"
- les variables doivent être déclarées au plus petit scope d'utilisation
- les variables de classes doivent être déclarées en début de classe
- les chaines de caractères utilisées à plusieurs endroits doivent être mises sous formes de constantes
- les messages d'information, d'erreur ou autres doivent être mis sous forme de Custom Label
- les imports type CustomLabel, Schéma, fonction utils sont regroupés dans un fichier "importUtility.js" et sont importés depuis le composant Global Utility
- Supprimer les variables inutilisées
- Supprimer les imports inutilisés
- Utiliser la nomenclature camelCase pour les variables
- Utiliser la nomenclature camelCase pour les méthodes
- Favoriser l'utilisation de "switch" plutôt que de "if" pour les conditions multiples

